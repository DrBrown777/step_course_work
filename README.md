# Самообучающаяся игра Крестики-Нолики
Курсовая работа Базовый курс С++

[![21e8653624f1adb230a0e37787c35e78.md.png](https://pickasso.info/images/2020/06/13/21e8653624f1adb230a0e37787c35e78.md.png)](https://pickasso.info/image/K0ITR)

Правила игры, всем известны подробно останавливаться не будем: Игровое поле 3х3, начинают Крестики, и ходят по очереди с Ноликами, побеждает тот, кто закроет три поля по вертикали, 
диагонали или горизонтали, также возможна ситуация Ничьи.
Программа, состоит из 3-х вариантов игр:
	
1. Тренировочный матч: Человек против Компьютера (компьютер играет Random стратегию).
	
2. Smart стратегия: Человек против Компьютера (компьютер играет на основании базы данных, состоящей из ситуаций (вариантов расположения X и О) на поле и соответствующей каждой ситуации, матрице весов).
	
3. Обучение Smart игрока: Компьютер Smart против компьютер Random (в данном случае Random игрок нужен для совместимости и обучения Smart игрока).

Как вы уже поняли, в игре присутствуют три типа игроков:

	-Человек

	-Компьютер, который играет Random стратегию.

	-Компьютер, который играет Smart стратегию.

Остановимся подробнее на Smart игроке и 3-ем варианте игры, так как это является основой для 2-го варианта. Хотя во втором варианте, Smart игрок тоже обучается, только медленнее, так как против него играет Человек. 

Для ускорения обучения игровое поле не выводится, а кол-во матчей задается переменной number_of_games и в базу данных записываются все ситуации на поле, примерно 4520 вариантов. 

При этом необходимо сыграть 100 000 партий, время обучения в среднем составляет 11-12 сек. База данных состоит из двух Структур типа DataBase: Collection_X и Collection_O, которые заполняются вариантами и весами, в зависимости от того, чем играет Smart игрок Х-ми или О-ми, и соответствующими полями матрицами весов. Перед каждой партией, случайным образом определяется кто за какой "символ" будет играть.

Изначально Smart игрок использует Random стратегию, и на каждом ходе ставит символ в случайную клетку. Если последовательность ходов приводит к победе, то она поощряется путем увеличения весов каждого хода, если к поражению, то наказывается, путем уменьшения весов. Если партия закончилась в Ничью, мы вес ходов не увеличиваем и не уменьшаем.

Перед каждым ходом Smart игрок консультируется с базой данных, и ищет ситуацию, которая уже встречалась ранее на поле, если такая ситуация не найдена, то вариант добавляется в базу и изначально вес ходов для каждой ситуации на поле равен 100.

История ходов Smart игрока в течении одной партии, записываются в отдельную структуру типа "Stack" Hystory, и в конце каждой партии используем её для выполнения итерации обучения с помощью рекурсии.  

Предположим, что Smart игрок выиграл на 4-м ходу, тогда, поощряем последовательность ходов и перезаписываем матрицу в базе данных:

	вес 1-го хода: + step_learn * step_coef^3 

	вес 2-го хода: + step_learn * step_coef^2

	вес 3-го хода: + step_learn * step_coef

	вес 4-го хода: + step_learn

где, step_learn - шаг обучения (от 10 до 30), по умолчанию равен 20, а step_coef - коэффициент обучения (от 0 до 1) по умолчанию равен 0,65.

В случае поражения, веса ходов уменьшаются аналогичным образом, в случае ничьи ничего не делаем. Рассмотрим более подробнее как Smart игрок генерирует ход на основании матрицы весов. Предположим, что матрица весов для какой-либо ситуации на поле выглядит следующим образом:
  
	0      50      80

	200     0      70

	100    100    100
На первом шаге мы нормализуем матрицу, и делим каждый элемент на сумму всех весов таблицы, в данном примере 700:

	0      0.07   0.11

	0.29      0    0.1
	
	0.14   0.14   0.14
Если все ходы одинаково плохи, т.е. сумма элементов равна 0, будет сгенерирован случайный ход, на основании пустых клеток, и нижеуказанные шаги мы не выполняем.

На втором шаге полученные элементы умножаются на precision_coef (точность генератора хода, по умолчанию равен 50), дробную часть отбрасываем, чем больше, тем точность будет выше:
 
 	0      3      5

	14     0      5
 
 	7      7      7
На третьем шаге, генерируется массив элементов (от 0 до 8 включительно), состоящих из стольких чисел, сколько записано в каждой клетке матрицы, соответствующей игровому полю:

	1 1 1 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 6 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 

На четвертом шаге, массив перемешивается случайным образом, и в качестве хода извлекается случайный элемент массива.

Почему случайным? Потому что мы должны дать Smart игроку право на ошибку, и дать игроку Человек хоть иногда выиграть или получить результат ничья, в противном случае играть будет не интересно. 

В заключении хочется сказать, что качество обучения зависит от трех основных параметрах, о которых упоминалось выше:

	1. precision_coef - точность генератора хода (по умолчанию 50)
	2. step_coef - коэффициент обучения (по умолчанию 0,65)
	3. step_learn - шаг обучения (по умолчанию 20)

С ними можно поэкспериментировать, и ввести в игру уровни сложности, в зависимости от выбранных параметров. Например, при параметрах по умолчанию статистка проведенных 100000 партий, между Smart и Random игроками выглядит следующим образом:

Smart играет Крестиками:

	Победы X – 89346   Победы O – 5599   Ничья – 5055

Smart играет Ноликами:

	Победы X – 9102   Победы O – 81182   Ничья – 9716

Смешанный тип, кто за какой символ играет выбирается случайным образом:

	Победы X – 50438   Победы O – 40910   Ничья – 8652

Крестики всегда ходят Первыми.
